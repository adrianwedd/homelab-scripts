#!/bin/bash

################################################################################
# Disk Cleanup Script
################################################################################
# Description: Comprehensive system cleanup to free up disk space
# Author: Generated by Claude Code
# Date: November 9, 2025
#
# This script cleans up various caches and unused files from:
# - VS Code
# - Docker
# - Git repositories
# - Homebrew
# - NPM
# - Playwright
# - pnpm
# - pip/Python
# - AWS CLI
################################################################################

# Exit on undefined variables, but NOT on errors (we want to continue cleanup)
set -u

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Configuration
DRY_RUN=false
INTERACTIVE=true
LOG_FILE="/tmp/disk_cleanup_$(date +%Y%m%d_%H%M%S).log"
VERBOSE=false
SKIP_GIT_GC=false

# Track total space freed (in bytes)
TOTAL_FREED_BYTES=0

# Cleanup on exit
cleanup_on_exit() {
    if [ -f "$LOG_FILE" ]; then
        print_info "Full log saved to: $LOG_FILE"
    fi
}
trap cleanup_on_exit EXIT

# Function to print colored output
print_info() {
    echo -e "${BLUE}ℹ${NC} ${1}" | tee -a "$LOG_FILE"
}

print_success() {
    echo -e "${GREEN}✓${NC} ${1}" | tee -a "$LOG_FILE"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} ${1}" | tee -a "$LOG_FILE"
}

print_error() {
    echo -e "${RED}✗${NC} ${1}" | tee -a "$LOG_FILE"
}

print_section() {
    echo "" | tee -a "$LOG_FILE"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" | tee -a "$LOG_FILE"
    echo -e "${BLUE}${BOLD}  ${1}${NC}" | tee -a "$LOG_FILE"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" | tee -a "$LOG_FILE"
}

# Function to convert size to bytes
size_to_bytes() {
    local size=$1
    local number=$(echo "$size" | sed 's/[^0-9.]*//g')
    local unit=$(echo "$size" | sed 's/[0-9.]*//g' | tr '[:lower:]' '[:upper:]')

    case "$unit" in
        K|KB) echo "$number * 1024" | bc -l | cut -d. -f1 ;;
        M|MB) echo "$number * 1024 * 1024" | bc -l | cut -d. -f1 ;;
        G|GB) echo "$number * 1024 * 1024 * 1024" | bc -l | cut -d. -f1 ;;
        T|TB) echo "$number * 1024 * 1024 * 1024 * 1024" | bc -l | cut -d. -f1 ;;
        B|*) echo "${number%.*}" ;;
    esac
}

# Function to convert bytes to human readable
bytes_to_human() {
    local bytes=$1
    if [ -z "$bytes" ] || [ "$bytes" = "0" ]; then
        echo "0B"
        return
    fi

    awk -v bytes="$bytes" 'BEGIN {
        if (bytes >= 1099511627776) printf "%.2fTB", bytes/1099511627776
        else if (bytes >= 1073741824) printf "%.2fGB", bytes/1073741824
        else if (bytes >= 1048576) printf "%.2fMB", bytes/1048576
        else if (bytes >= 1024) printf "%.2fKB", bytes/1024
        else printf "%dB", bytes
    }'
}

# Function to get directory size in bytes
get_dir_size_bytes() {
    if [ -d "$1" ]; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            du -sk "$1" 2>/dev/null | awk '{print $1 * 1024}'
        else
            # Linux
            du -sb "$1" 2>/dev/null | awk '{print $1}'
        fi
    else
        echo "0"
    fi
}

# Function to get directory size (human readable)
get_dir_size() {
    local bytes=$(get_dir_size_bytes "$1")
    bytes_to_human "$bytes"
}

# Function to track freed space
track_freed_space() {
    local before_bytes=$1
    local after_bytes=$2
    local freed=$((before_bytes - after_bytes))

    if [ $freed -gt 0 ]; then
        TOTAL_FREED_BYTES=$((TOTAL_FREED_BYTES + freed))
        echo "$freed"
    else
        echo "0"
    fi
}

# Function to confirm action
confirm_action() {
    if [ "$INTERACTIVE" = false ]; then
        return 0
    fi

    # In dry run mode, skip confirmations
    if [ "$DRY_RUN" = true ]; then
        return 0
    fi

    local message=$1
    echo -e "${YELLOW}?${NC} ${message} (y/N): " | tee -a "$LOG_FILE"
    read -r response
    echo "$response" >> "$LOG_FILE"

    if [[ "$response" =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to safely remove directory
safe_remove() {
    local dir=$1
    local desc=$2

    if [ ! -d "$dir" ]; then
        return 0
    fi

    local size_before=$(get_dir_size_bytes "$dir")
    local size_human=$(bytes_to_human "$size_before")

    if [ "$DRY_RUN" = true ]; then
        print_info "[DRY RUN] Would remove: $dir ($size_human)"
        return 0
    fi

    print_info "Removing: $dir ($size_human)"

    if rm -rf "$dir" 2>/dev/null; then
        local freed=$(track_freed_space "$size_before" 0)
        print_success "Removed $desc: $(bytes_to_human $freed) freed"
        return 0
    else
        print_error "Failed to remove: $dir"
        return 1
    fi
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Comprehensive disk cleanup script to free up space from caches and temporary files.

OPTIONS:
    -d, --dry-run       Preview what would be cleaned without making changes
    -y, --yes           Skip confirmation prompts (non-interactive mode)
    -v, --verbose       Show detailed output
    --skip-git-gc       Skip git garbage collection (saves time)
    -h, --help          Show this help message

EXAMPLES:
    $0                  # Interactive cleanup with confirmations
    $0 --dry-run        # Preview cleanup without changes
    $0 -y               # Non-interactive cleanup (auto-confirm)
    $0 -y --skip-git-gc # Quick cleanup, skip git gc

EOF
}

################################################################################
# Parse command line arguments
################################################################################
while [[ $# -gt 0 ]]; do
    case $1 in
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -y|--yes)
            INTERACTIVE=false
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --skip-git-gc)
            SKIP_GIT_GC=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
    esac
done

################################################################################
# Start cleanup
################################################################################
print_section "Disk Cleanup Script"
print_info "Started at: $(date)"
print_info "Log file: $LOG_FILE"

if [ "$DRY_RUN" = true ]; then
    print_warning "DRY RUN MODE - No changes will be made"
fi

echo "" | tee -a "$LOG_FILE"

################################################################################
# 1. VS Code Caches
################################################################################
print_section "Cleaning VS Code Caches"

VSCODE_CACHE_DIRS=(
    "$HOME/Library/Application Support/Code/Cache"
    "$HOME/Library/Application Support/Code/CachedData"
    "$HOME/Library/Application Support/Code/CachedExtensions"
    "$HOME/Library/Application Support/Code/CachedExtensionVSIXs"
    "$HOME/Library/Application Support/Code/User/workspaceStorage"
)

vscode_cleaned=false
for dir in "${VSCODE_CACHE_DIRS[@]}"; do
    if [ -d "$dir" ]; then
        if ! $vscode_cleaned; then
            if ! confirm_action "Clean VS Code caches?"; then
                print_info "Skipping VS Code cleanup"
                break
            fi
            vscode_cleaned=true
        fi
        safe_remove "$dir" "VS Code cache"
    fi
done

if ! $vscode_cleaned; then
    print_info "No VS Code caches found"
fi

################################################################################
# 2. Docker Cleanup
################################################################################
print_section "Cleaning Docker"

if command -v docker &> /dev/null; then
    # Check if Docker daemon is running
    if ! docker info &> /dev/null; then
        print_warning "Docker daemon is not running"

        if confirm_action "Start Docker daemon?"; then
            print_info "Starting Docker..."

            # Try different methods based on OS
            if [[ "$OSTYPE" == "darwin"* ]]; then
                # macOS - use open command
                open -a Docker 2>/dev/null || open --background -a Docker 2>/dev/null

                # Wait for Docker to start (up to 60 seconds)
                print_info "Waiting for Docker daemon to start..."
                waited=0
                while [ $waited -lt 60 ] && ! docker info &> /dev/null; do
                    sleep 2
                    waited=$((waited + 2))
                    echo -n "."
                done
                echo ""

                if docker info &> /dev/null; then
                    print_success "Docker daemon started successfully"
                else
                    print_error "Failed to start Docker daemon after ${waited}s"
                    print_info "Please start Docker Desktop manually"
                    print_info "Skipping Docker cleanup"
                fi
            else
                # Linux - try systemctl
                if command -v systemctl &> /dev/null; then
                    if sudo systemctl start docker 2>/dev/null; then
                        sleep 3
                        if docker info &> /dev/null; then
                            print_success "Docker daemon started successfully"
                        else
                            print_error "Failed to start Docker daemon"
                            print_info "Skipping Docker cleanup"
                        fi
                    else
                        print_error "Failed to start Docker daemon"
                        print_info "Try: sudo systemctl start docker"
                        print_info "Skipping Docker cleanup"
                    fi
                else
                    print_error "Cannot start Docker daemon automatically"
                    print_info "Please start Docker manually"
                    print_info "Skipping Docker cleanup"
                fi
            fi
        else
            print_info "Skipping Docker cleanup"
        fi
    fi

    # Proceed with cleanup if Docker is now running
    if docker info &> /dev/null && confirm_action "Clean Docker (removes unused containers, images, volumes)?"; then
        if [ "$DRY_RUN" = true ]; then
            print_info "[DRY RUN] Would run: docker system prune -af --volumes"
            docker system df 2>&1 | tee -a "$LOG_FILE"
        else
            print_info "Running Docker system prune..."
            docker system prune -af --volumes 2>&1 | tee -a "$LOG_FILE" | tee /tmp/docker_cleanup.log

            if grep -q "Total reclaimed space" /tmp/docker_cleanup.log; then
                space=$(grep "Total reclaimed space" /tmp/docker_cleanup.log | awk '{print $(NF-1), $NF}')
                space_bytes=$(size_to_bytes "$space")
                TOTAL_FREED_BYTES=$((TOTAL_FREED_BYTES + space_bytes))
                print_success "Docker cleanup completed. Space freed: $space"
            else
                print_success "Docker cleanup completed"
            fi
            rm -f /tmp/docker_cleanup.log
        fi
    else
        print_info "Skipping Docker cleanup"
    fi
else
    print_warning "Docker not found, skipping"
fi

################################################################################
# 3. Git Garbage Collection
################################################################################
if [ "$SKIP_GIT_GC" = false ]; then
    print_section "Git Garbage Collection"

    print_info "Searching for Git repositories in ~/repos..."

    # Use array to avoid word splitting issues
    mapfile -t git_repos < <(find ~/repos -name ".git" -type d 2>/dev/null | sed 's|/.git||')

    if [ ${#git_repos[@]} -eq 0 ]; then
        print_warning "No Git repositories found"
    else
        repo_count=${#git_repos[@]}
        print_info "Found $repo_count Git repositories"

        if confirm_action "Run git gc on all repositories? (This may take a while)"; then
            current=0
            failed=0
            ORIGINAL_DIR=$(pwd)

            for repo in "${git_repos[@]}"; do
                current=$((current + 1))
                print_info "[$current/$repo_count] Processing: $repo"

                if [ ! -d "$repo" ]; then
                    print_warning "Repository no longer exists: $repo"
                    continue
                fi

                cd "$repo" || {
                    print_error "Cannot access repository: $repo"
                    failed=$((failed + 1))
                    continue
                }

                # Get repo size before
                size_before=$(get_dir_size_bytes ".")
                size_before_human=$(bytes_to_human "$size_before")

                if [ "$DRY_RUN" = true ]; then
                    print_info "[DRY RUN] Would run git gc on: $repo (Current size: $size_before_human)"
                else
                    # Run git gc with timeout protection
                    print_info "Running git gc (size: $size_before_human)..."

                    if timeout 1800 git gc --aggressive --prune=now 2>&1 | tee -a "$LOG_FILE" | grep -qE "error|fatal"; then
                        print_warning "Git gc encountered issues in $repo"
                        failed=$((failed + 1))
                    else
                        size_after=$(get_dir_size_bytes ".")
                        size_after_human=$(bytes_to_human "$size_after")
                        freed=$(track_freed_space "$size_before" "$size_after")

                        if [ "$freed" -gt 0 ]; then
                            print_success "Completed: $(bytes_to_human $freed) freed (was $size_before_human, now $size_after_human)"
                        else
                            print_success "Completed (no size change)"
                        fi
                    fi
                fi
            done

            # Return to original directory
            cd "$ORIGINAL_DIR" || exit 1

            if [ $failed -gt 0 ]; then
                print_warning "Git gc failed for $failed repositories"
            fi
        else
            print_info "Skipping Git garbage collection"
        fi
    fi
else
    print_section "Git Garbage Collection"
    print_info "Skipped (--skip-git-gc flag used)"
fi

################################################################################
# 4. Homebrew Cleanup
################################################################################
print_section "Cleaning Homebrew"

if command -v brew &> /dev/null; then
    if confirm_action "Clean Homebrew caches?"; then
        if [ "$DRY_RUN" = true ]; then
            print_info "[DRY RUN] Would run: brew cleanup --prune=all -s"
        else
            print_info "Running brew cleanup..."
            brew cleanup --prune=all -s 2>&1 | tee -a "$LOG_FILE" | tee /tmp/brew_cleanup.log

            # Try to extract space freed
            if grep -qE "Pruned|freed|removed" /tmp/brew_cleanup.log; then
                space_line=$(grep -E "Pruned|freed|removed" /tmp/brew_cleanup.log | tail -1)
                print_success "Homebrew cleanup completed: $space_line"
            else
                print_success "Homebrew cleanup completed"
            fi
            rm -f /tmp/brew_cleanup.log
        fi
    else
        print_info "Skipping Homebrew cleanup"
    fi
else
    print_warning "Homebrew not found, skipping"
fi

################################################################################
# 5. NPM Cache
################################################################################
print_section "Cleaning NPM Cache"

if command -v npm &> /dev/null; then
    cache_dir=$(npm config get cache 2>/dev/null || echo "$HOME/.npm")

    if [ -d "$cache_dir" ]; then
        size_before=$(get_dir_size_bytes "$cache_dir")
        size_before_human=$(bytes_to_human "$size_before")

        print_info "NPM cache location: $cache_dir (Size: $size_before_human)"

        if confirm_action "Clean NPM cache?"; then
            if [ "$DRY_RUN" = true ]; then
                print_info "[DRY RUN] Would run: npm cache clean --force"
            else
                print_info "Running npm cache clean..."
                npm cache clean --force 2>&1 | tee -a "$LOG_FILE"

                size_after=$(get_dir_size_bytes "$cache_dir")
                freed=$(track_freed_space "$size_before" "$size_after")
                print_success "NPM cache cleaned: $(bytes_to_human $freed) freed"
            fi
        else
            print_info "Skipping NPM cleanup"
        fi
    else
        print_warning "NPM cache directory not found"
    fi
else
    print_warning "NPM not found, skipping"
fi

################################################################################
# 6. Playwright Browsers
################################################################################
print_section "Cleaning Playwright Browsers"

if command -v npx &> /dev/null; then
    playwright_cache="$HOME/Library/Caches/ms-playwright"

    if [ -d "$playwright_cache" ]; then
        size_before=$(get_dir_size_bytes "$playwright_cache")
        size_before_human=$(bytes_to_human "$size_before")

        print_info "Playwright cache: $playwright_cache (Size: $size_before_human)"

        if confirm_action "Uninstall all Playwright browsers?"; then
            if [ "$DRY_RUN" = true ]; then
                print_info "[DRY RUN] Would run: npx playwright uninstall --all"
            else
                print_info "Uninstalling all Playwright browsers..."
                npx playwright uninstall --all 2>&1 | tee -a "$LOG_FILE"

                size_after=$(get_dir_size_bytes "$playwright_cache")
                freed=$(track_freed_space "$size_before" "$size_after")
                print_success "Playwright browsers removed: $(bytes_to_human $freed) freed"
            fi
        else
            print_info "Skipping Playwright cleanup"
        fi
    else
        print_warning "No Playwright cache found"
    fi
else
    print_warning "npx not found, skipping Playwright cleanup"
fi

################################################################################
# 7. pnpm Store
################################################################################
print_section "Cleaning pnpm Store"

if command -v pnpm &> /dev/null; then
    if confirm_action "Prune pnpm store?"; then
        if [ "$DRY_RUN" = true ]; then
            print_info "[DRY RUN] Would run: pnpm store prune"
        else
            print_info "Running pnpm store prune..."
            pnpm store prune 2>&1 | tee -a "$LOG_FILE" | tee /tmp/pnpm_cleanup.log

            if grep -q "removed" /tmp/pnpm_cleanup.log; then
                packages=$(grep "removed" /tmp/pnpm_cleanup.log | head -1)
                print_success "pnpm store pruned: $packages"
            else
                print_success "pnpm store pruned"
            fi
            rm -f /tmp/pnpm_cleanup.log
        fi
    else
        print_info "Skipping pnpm cleanup"
    fi
else
    print_warning "pnpm not found, skipping"
fi

################################################################################
# 8. pip/Python Cache
################################################################################
print_section "Cleaning pip/Python Cache"

if command -v pip &> /dev/null || command -v pip3 &> /dev/null; then
    PIP_CMD="pip"
    command -v pip3 &> /dev/null && PIP_CMD="pip3"

    cache_dir=$($PIP_CMD cache dir 2>/dev/null || echo "$HOME/Library/Caches/pip")

    if [ -d "$cache_dir" ]; then
        size_before=$(get_dir_size_bytes "$cache_dir")
        size_before_human=$(bytes_to_human "$size_before")

        print_info "pip cache location: $cache_dir (Size: $size_before_human)"

        if confirm_action "Purge pip cache?"; then
            if [ "$DRY_RUN" = true ]; then
                print_info "[DRY RUN] Would run: $PIP_CMD cache purge"
            else
                print_info "Running pip cache purge..."
                $PIP_CMD cache purge 2>&1 | tee -a "$LOG_FILE" | tee /tmp/pip_cleanup.log

                size_after=$(get_dir_size_bytes "$cache_dir")
                freed=$(track_freed_space "$size_before" "$size_after")

                if grep -q "Files removed" /tmp/pip_cleanup.log; then
                    files=$(grep "Files removed" /tmp/pip_cleanup.log)
                    print_success "pip cache purged: $files ($(bytes_to_human $freed) freed)"
                else
                    print_success "pip cache purged: $(bytes_to_human $freed) freed"
                fi
                rm -f /tmp/pip_cleanup.log
            fi
        else
            print_info "Skipping pip cleanup"
        fi
    else
        print_warning "pip cache directory not found"
    fi
else
    print_warning "pip not found, skipping"
fi

################################################################################
# 9. AWS CLI Cache
################################################################################
print_section "Cleaning AWS CLI Cache"

AWS_CACHE_DIR="$HOME/.aws/cli/cache"
if [ -d "$AWS_CACHE_DIR" ]; then
    size_before=$(get_dir_size_bytes "$AWS_CACHE_DIR")
    size_before_human=$(bytes_to_human "$size_before")

    print_info "AWS CLI cache: $AWS_CACHE_DIR (Size: $size_before_human)"

    if confirm_action "Clean AWS CLI cache?"; then
        if [ "$DRY_RUN" = true ]; then
            print_info "[DRY RUN] Would remove: $AWS_CACHE_DIR/*"
        else
            rm -rf "$AWS_CACHE_DIR"/* 2>&1 | tee -a "$LOG_FILE"

            freed=$(track_freed_space "$size_before" 0)
            print_success "AWS CLI cache cleaned: $(bytes_to_human $freed) freed"
        fi
    else
        print_info "Skipping AWS cleanup"
    fi
else
    print_warning "No AWS CLI cache found"
fi

################################################################################
# Summary
################################################################################
print_section "Cleanup Complete!"

if [ "$DRY_RUN" = true ]; then
    print_warning "DRY RUN completed - no changes were made"
else
    total_freed_human=$(bytes_to_human "$TOTAL_FREED_BYTES")
    print_success "Total space freed: $total_freed_human"
fi

print_info "Completed at: $(date)"
print_info "Full log saved to: $LOG_FILE"

echo "" | tee -a "$LOG_FILE"
print_info "To see current disk usage, run: df -h"

if [ "$DRY_RUN" = true ]; then
    echo "" | tee -a "$LOG_FILE"
    print_info "To perform actual cleanup, run: $0 -y"
fi

echo "" | tee -a "$LOG_FILE"
