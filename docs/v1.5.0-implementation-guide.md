# v1.5.0 Risk Scoring - Implementation Guide

## Overview

This guide provides a complete implementation plan for adding risk scoring to ssh-key-audit.sh. The feature is fully spec'd and ready for coding.

## Design Principles

1. **Pure bash** - No jq dependency for scoring
2. **Associative arrays** - Store risk data in `RISK_SCORES[user]`, `RISK_LEVELS[user]`, `RISK_FACTORS_JSON[user]`
3. **Per-target initialization** - Declare `keys_data=()` inside `audit_auth_keys()`
4. **Graceful degradation** - If config fails to load, set `ENABLE_RISK=false` and skip all risk code
5. **Clean console layout** - Risk summary appears after standard summary with blank line separator

## Files to Modify/Create

### New Files
- ‚úÖ `examples/ssh-audit.conf` - Sample config (DONE)
- üìù `docs/releases/v1.5.0-release-notes.md` - Release documentation

### Modified Files
- üìù `ssh-key-audit.sh` - Add risk scoring functionality
- üìù `CHANGELOG.md` - Add v1.5.0 entry

## Implementation Steps

### Step 1: Add Global State Variables

Add after line 38 (after `TARGETS_MISSING_KEYS=0`):

```bash
# Risk scoring state (v1.5.0+)
ENABLE_RISK=false
RISK_DETAIL=false
RISK_CONFIG_PATH=""
declare -A RISK_SCORES       # RISK_SCORES[user]=score
declare -A RISK_LEVELS       # RISK_LEVELS[user]=level
declare -A RISK_FACTORS_JSON # RISK_FACTORS_JSON[user]=json_array_string
```

### Step 2: Add Risk Descriptions Lookup Table

Add after the helper functions (around line 155):

```bash
# Risk factor descriptions (v1.5.0+)
declare -A RISK_DESCRIPTIONS=(
  # Target-level issues
  ["ssh-dir-perms"]="World-readable ~/.ssh directory exposes key material"
  ["auth-keys-perms"]="authorized_keys permissions allow unauthorized modification"
  ["auth-keys-missing"]="No authorized_keys file present (informational)"

  # Key type issues
  ["weak-type:ssh-rsa"]="SHA-1 collision vulnerability in ssh-rsa signatures (deprecated OpenSSH 8.8+)"
  ["weak-type:ssh-dss"]="Weak DSA signatures (removed OpenSSH 7.0+)"
  ["weak-type:ecdsa-sha2-nistp256"]="NIST P-256 curve (potential backdoor concerns)"
  ["weak-type:ecdsa-sha2-nistp384"]="NIST P-384 curve (potential backdoor concerns)"
  ["weak-type:ecdsa-sha2-nistp521"]="NIST P-521 curve (potential backdoor concerns)"

  # Key hygiene issues
  ["unsafe-options"]="Unsafe key options enable command injection or lateral movement"
  ["duplicate"]="Key reuse across targets increases blast radius on compromise"
  ["stale"]="Key age exceeds policy threshold (rotation recommended)"
)
```

### Step 3: Add Risk Scoring Functions

Add after the risk descriptions (5 functions):

1. **set_default_risk_weights()** - Set default weights
2. **clamp_weight()** - Validate and clamp weights to [0,100]
3. **validate_risk_config()** - Validate all loaded weights
4. **load_risk_config()** - Priority-based config discovery
5. **calculate_risk_score()** - Pure bash scoring engine

See detailed function implementations in the "Function Implementations" section below.

### Step 4: Update CLI Argument Parsing

Add to defaults section (around line 28):

```bash
ENABLE_RISK=false
RISK_DETAIL=false
RISK_CONFIG_PATH=""
```

Add to argument parsing loop (around line 86):

```bash
    --risk) ENABLE_RISK=true; shift;;
    --risk-detail) ENABLE_RISK=true; RISK_DETAIL=true; shift;;
    --risk-config) RISK_CONFIG_PATH="$2"; shift 2;;
```

Add after argument parsing (around line 102):

```bash
# Load risk config if enabled
if [ "$ENABLE_RISK" = true ]; then
  load_risk_config
fi
```

### Step 5: Update help text

Add to show_help() function:

```bash
  --risk                  Enable risk scoring (adds risk_* fields to JSON)
  --risk-detail           Show detailed risk breakdown per target (implies --risk)
  --risk-config PATH      Load risk weights from config file
```

### Step 6: Integrate into audit_auth_keys()

Add at top of function (around line 215):

```bash
  # Initialize per-target risk tracking (v1.5.0+)
  declare -a target_issues=()  # Already exists from v1.4.3
  declare -a keys_data=()      # NEW for v1.5.0
```

In the key parsing loop, add after building keys_json (around line 365):

```bash
    # Build keys_data for risk scoring (if enabled) - v1.5.0+
    if [ "$ENABLE_RISK" = true ]; then
      local issues_str=$(IFS=','; echo "${issues[*]}")
      keys_data+=("$key_type|$key_comment|$issues_str")
    fi
```

After key loop completes, add risk scoring (around line 368):

```bash
  # Calculate risk score (v1.5.0+)
  if [ "$ENABLE_RISK" = true ]; then
    local risk_json=$(calculate_risk_score "$target_user" "$is_system" target_issues "${keys_data[@]}")

    # Parse and store in associative arrays (using awk, not grep!)
    local score=$(echo "$risk_json" | awk -F'"risk_score": ' '{print $2}' | awk -F',' '{print $1}')
    local level=$(echo "$risk_json" | awk -F'"risk_level": "' '{print $2}' | awk -F'"' '{print $1}')
    local factors=$(echo "$risk_json" | awk -F'"risk_factors": ' '{print $2}' | sed 's/}$//')

    RISK_SCORES["$target_user"]=$score
    RISK_LEVELS["$target_user"]=$level
    RISK_FACTORS_JSON["$target_user"]=$factors
  fi
```

Update JSON construction (around line 395):

```bash
  # Build final JSON with risk fields (v1.5.0+)
  if [ "$ENABLE_RISK" = true ]; then
    json_buf_users+=("{ \"user\": \"$esc_user\", \"path\": \"$esc_path\", \"is_system\": $is_system_json, \"target_issues\": $target_issues_json, \"risk_score\": ${RISK_SCORES[$target_user]}, \"risk_level\": \"${RISK_LEVELS[$target_user]}\", \"risk_factors\": ${RISK_FACTORS_JSON[$target_user]}, \"keys\": [ $keys_joined ] }")
  else
    json_buf_users+=("{ \"user\": \"$esc_user\", \"path\": \"$esc_path\", \"is_system\": $is_system_json, \"target_issues\": $target_issues_json, \"keys\": [ $keys_joined ] }")
  fi
```

**IMPORTANT**: Apply same changes to the early-return path (when authorized_keys is missing, around line 228-248).

### Step 7: Add Console Risk Summary Output

Add two functions after the audit loop (before final summary):

1. **print_risk_summary()** - Main risk summary display
2. **print_risk_detail()** - Detailed breakdown for specific target

See detailed function implementations in the "Function Implementations" section below.

### Step 8: Wire Console Output

After the existing summary block (around line 439), add:

```bash
# Add risk summary with blank line separator (v1.5.0+)
if [ "$ENABLE_RISK" = true ]; then
  echo  # Blank line between sections
  print_risk_summary
fi
```

## Function Implementations

### clamp_weight()

```bash
# Clamp risk weight to valid range [0, 100]
clamp_weight() {
  local weight=$1

  # Validate numeric
  if ! [[ "$weight" =~ ^[0-9]+$ ]]; then
    print_warning "Invalid risk weight: $weight (not numeric), using 0"
    echo 0
    return
  fi

  # Clamp to [0, 100]
  if [ "$weight" -lt 0 ]; then
    print_warning "Risk weight $weight < 0, clamping to 0"
    echo 0
  elif [ "$weight" -gt 100 ]; then
    print_warning "Risk weight $weight > 100, clamping to 100"
    echo 100
  else
    echo "$weight"
  fi
}
```

### set_default_risk_weights()

```bash
# Set default risk scoring weights
set_default_risk_weights() {
  # Target-level weights
  : "${SSH_AUDIT_RISK_SSH_DIR_PERMS:=40}"
  : "${SSH_AUDIT_RISK_AUTH_KEYS_PERMS:=35}"
  : "${SSH_AUDIT_RISK_AUTH_KEYS_MISSING:=5}"

  # Key type weights (weak crypto)
  : "${SSH_AUDIT_RISK_WEAK_SSH_RSA:=50}"
  : "${SSH_AUDIT_RISK_WEAK_SSH_DSS:=50}"
  : "${SSH_AUDIT_RISK_WEAK_ECDSA_NIST:=0}"  # Default 0, opt-in via config

  # Key hygiene weights
  : "${SSH_AUDIT_RISK_UNSAFE_OPTIONS:=35}"
  : "${SSH_AUDIT_RISK_DUPLICATE:=20}"

  # Stale key thresholds (>= days)
  : "${SSH_AUDIT_RISK_STALE_365:=25}"
  : "${SSH_AUDIT_RISK_STALE_180:=15}"
  : "${SSH_AUDIT_RISK_STALE_90:=8}"

  # Risk level thresholds
  : "${SSH_AUDIT_RISK_THRESHOLD_CRITICAL:=85}"
  : "${SSH_AUDIT_RISK_THRESHOLD_HIGH:=50}"
  : "${SSH_AUDIT_RISK_THRESHOLD_MEDIUM:=20}"
  : "${SSH_AUDIT_RISK_THRESHOLD_LOW:=1}"

  # Scoring modifiers
  : "${SSH_AUDIT_RISK_SYSTEM_MULTIPLIER:=1.25}"
  : "${SSH_AUDIT_RISK_TARGET_MAX:=100}"
  : "${SSH_AUDIT_RISK_KEY_MAX:=100}"

  # Display options
  : "${SSH_AUDIT_RISK_TOP_N:=5}"
}
```

### validate_risk_config()

```bash
# Validate all risk weights on config load
validate_risk_config() {
  # Validate and clamp all weights
  SSH_AUDIT_RISK_SSH_DIR_PERMS=$(clamp_weight "$SSH_AUDIT_RISK_SSH_DIR_PERMS")
  SSH_AUDIT_RISK_AUTH_KEYS_PERMS=$(clamp_weight "$SSH_AUDIT_RISK_AUTH_KEYS_PERMS")
  SSH_AUDIT_RISK_AUTH_KEYS_MISSING=$(clamp_weight "$SSH_AUDIT_RISK_AUTH_KEYS_MISSING")
  SSH_AUDIT_RISK_WEAK_SSH_RSA=$(clamp_weight "$SSH_AUDIT_RISK_WEAK_SSH_RSA")
  SSH_AUDIT_RISK_WEAK_SSH_DSS=$(clamp_weight "$SSH_AUDIT_RISK_WEAK_SSH_DSS")
  SSH_AUDIT_RISK_WEAK_ECDSA_NIST=$(clamp_weight "$SSH_AUDIT_RISK_WEAK_ECDSA_NIST")
  SSH_AUDIT_RISK_UNSAFE_OPTIONS=$(clamp_weight "$SSH_AUDIT_RISK_UNSAFE_OPTIONS")
  SSH_AUDIT_RISK_DUPLICATE=$(clamp_weight "$SSH_AUDIT_RISK_DUPLICATE")
  SSH_AUDIT_RISK_STALE_365=$(clamp_weight "$SSH_AUDIT_RISK_STALE_365")
  SSH_AUDIT_RISK_STALE_180=$(clamp_weight "$SSH_AUDIT_RISK_STALE_180")
  SSH_AUDIT_RISK_STALE_90=$(clamp_weight "$SSH_AUDIT_RISK_STALE_90")

  # Validate thresholds
  SSH_AUDIT_RISK_THRESHOLD_CRITICAL=$(clamp_weight "$SSH_AUDIT_RISK_THRESHOLD_CRITICAL")
  SSH_AUDIT_RISK_THRESHOLD_HIGH=$(clamp_weight "$SSH_AUDIT_RISK_THRESHOLD_HIGH")
  SSH_AUDIT_RISK_THRESHOLD_MEDIUM=$(clamp_weight "$SSH_AUDIT_RISK_THRESHOLD_MEDIUM")
  SSH_AUDIT_RISK_THRESHOLD_LOW=$(clamp_weight "$SSH_AUDIT_RISK_THRESHOLD_LOW")
}
```

### load_risk_config()

```bash
# Load risk scoring configuration from file or env
load_risk_config() {
  # Skip if risk scoring disabled
  [ "$ENABLE_RISK" != "true" ] && return 0

  # Always set defaults first (env vars will override)
  set_default_risk_weights

  # Search paths in priority order
  local config_file=""

  # 1. Explicit --risk-config path
  if [ -n "$RISK_CONFIG_PATH" ] && [ -f "$RISK_CONFIG_PATH" ]; then
    config_file="$RISK_CONFIG_PATH"
  # 2. Repo-local override
  elif [ -f "./.ssh-audit.conf" ]; then
    config_file="./.ssh-audit.conf"
  # 3. User home config
  elif [ -f "$HOME/.ssh-audit.conf" ]; then
    config_file="$HOME/.ssh-audit.conf"
  # 4. System-wide config
  elif [ -f "/etc/ssh-audit/config.conf" ]; then
    config_file="/etc/ssh-audit/config.conf"
  fi

  # Source config if found
  if [ -n "$config_file" ]; then
    print_info "Loading risk config: $config_file"

    if source "$config_file" 2>/dev/null; then
      # Validate loaded weights
      validate_risk_config
      return 0
    else
      print_error "Failed to load risk config: $config_file (syntax error)"
      print_error "Risk scoring disabled for this run"
      ENABLE_RISK=false
      return 1
    fi
  fi

  # No config file, using defaults
  print_info "Using built-in risk scoring defaults"
  validate_risk_config
  return 0
}
```

### calculate_risk_score()

**NOTE**: This is a large function (~150 lines). Full implementation is in the design document from our session. Key points:

- Takes: `target_user`, `is_system`, `target_issues` array reference, `keys_data` array
- Returns: JSON with `risk_score`, `risk_level`, `risk_factors`
- Uses pure bash (no jq)
- Formula: `final_score = min(target_score + max_key_score, 100) * multiplier_if_system`
- Stale keys use `>= threshold` logic (not additive)
- Descriptions include actual age for stale keys: "Key age exceeds threshold (547 days)"

### print_risk_summary()

**NOTE**: This is a large function (~100 lines). Key points:

- Checks `ENABLE_RISK=true` first
- Iterates over `RISK_LEVELS` associative array (NO JSON parsing!)
- Groups targets by risk level (CRITICAL, HIGH, MEDIUM, LOW, CLEAN)
- Prints color-coded distribution
- Sorts all risky targets by score (descending)
- Shows top N with scores and top 2 issues
- Calls `print_risk_detail()` if `RISK_DETAIL=true`

### print_risk_detail()

**NOTE**: Medium function (~80 lines). Key points:

- Takes `target_user` parameter
- Accesses `RISK_SCORES[user]`, `RISK_LEVELS[user]`, `RISK_FACTORS_JSON[user]`
- Parses risk_factors JSON minimally (only for display, using awk not grep)
- Shows target-level and key-level issues with icons (üî¥üü†üü°üîµüü¢)
- Groups key issues by key_index

## Testing Plan

### Test Scenario 1: Basic Risk Scoring

```bash
test_dir="/tmp/test_v150_basic"
rm -rf "$test_dir"

# User with ssh-rsa key (weak crypto)
mkdir -p "$test_dir/alice/.ssh"
chmod 700 "$test_dir/alice/.ssh"
echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC... alice@host' > "$test_dir/alice/.ssh/authorized_keys"
chmod 600 "$test_dir/alice/.ssh/authorized_keys"

# User with bad .ssh perms
mkdir -p "$test_dir/bob/.ssh"
chmod 755 "$test_dir/bob/.ssh"
echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGq9... bob@host' > "$test_dir/bob/.ssh/authorized_keys"
chmod 600 "$test_dir/bob/.ssh/authorized_keys"

# Clean user
mkdir -p "$test_dir/charlie/.ssh"
chmod 700 "$test_dir/charlie/.ssh"
echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDq9... charlie@host' > "$test_dir/charlie/.ssh/authorized_keys"
chmod 600 "$test_dir/charlie/.ssh/authorized_keys"

./ssh-key-audit.sh --users "alice,bob,charlie" --home-root "$test_dir" --risk --json
```

**Expected Output:**
- Alice: HIGH risk (weak-type:ssh-rsa = 50 pts)
- Bob: MEDIUM risk (ssh-dir-perms:755 = 40 pts)
- Charlie: CLEAN (0 pts)
- Console shows risk summary with color-coded levels
- JSON includes risk_score, risk_level, risk_factors

### Test Scenario 2: Risk Detail Mode

```bash
./ssh-key-audit.sh --users "alice,bob,charlie" --home-root "$test_dir" --risk-detail
```

**Expected Output:**
- Same as above, plus detailed breakdown showing:
  - Target-level issues with icons
  - Per-key issues with icons
  - Weights for each factor

### Test Scenario 3: Custom Config

```bash
# Create custom config
cat > /tmp/custom-risk.conf <<EOF
SSH_AUDIT_RISK_WEAK_SSH_RSA=75
SSH_AUDIT_RISK_SSH_DIR_PERMS=60
EOF

./ssh-key-audit.sh --users "alice,bob" --home-root "$test_dir" --risk --risk-config /tmp/custom-risk.conf
```

**Expected Output:**
- Alice: CRITICAL risk (75 pts)
- Bob: HIGH risk (60 pts)
- Console shows config loaded message

### Test Scenario 4: Config Error Handling

```bash
# Create broken config
echo "syntax error {{{" > /tmp/broken.conf

./ssh-key-audit.sh --users "alice" --home-root "$test_dir" --risk --risk-config /tmp/broken.conf
```

**Expected Output:**
- Error message: "Failed to load risk config"
- Message: "Risk scoring disabled for this run"
- Audit continues without risk fields
- No crash

### Test Scenario 5: Without --risk Flag

```bash
./ssh-key-audit.sh --users "alice,bob,charlie" --home-root "$test_dir" --json
```

**Expected Output:**
- No risk summary section
- JSON does NOT include risk_score, risk_level, risk_factors
- Works exactly like v1.4.3

## Version Update Checklist

- [ ] Update version in ssh-key-audit.sh header (line 5): `1.4.3` ‚Üí `1.5.0`
- [ ] Update version in help text (line 72): `1.4.3` ‚Üí `1.5.0`
- [ ] Add v1.5.0 entry to CHANGELOG.md
- [ ] Create docs/releases/v1.5.0-release-notes.md
- [ ] Test all scenarios above
- [ ] Run shellcheck (should pass)
- [ ] Commit with message template below

## Commit Message Template

```
Release v1.5.0: Risk scoring and prioritization

Added comprehensive risk scoring system for SSH key hygiene audits with configurable
weights and console prioritization.

Features:
- Pure bash risk scoring (no jq dependency)
- Configurable weights via config file or env vars
- Target score + max key score formula (capped at 100)
- System multiplier (1.25x) for /etc/ssh, /root targets
- Stale key buckets: 90/180/365 days (non-additive)
- Risk levels: CRITICAL (85+), HIGH (50-84), MEDIUM (20-49), LOW (1-19)
- Console summary with color-coded risk levels
- Detailed breakdown with --risk-detail
- Config discovery: --risk-config ‚Üí ./.ssh-audit.conf ‚Üí ~/.ssh-audit.conf ‚Üí /etc/ssh-audit/config.conf

CLI Flags:
- --risk: Enable risk scoring
- --risk-detail: Show detailed breakdown
- --risk-config PATH: Custom config file

Default Weights:
- ssh-rsa/ssh-dss: 50 pts (critical)
- Unsafe options: 35 pts
- Bad .ssh perms: 40 pts
- Bad authorized_keys perms: 35 pts
- Stale 365+ days: 25 pts
- Duplicate keys: 20 pts

Breaking Changes:
- None (opt-in via --risk flag)

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

## Success Criteria

Before committing v1.5.0, verify:

1. ‚úÖ All test scenarios pass
2. ‚úÖ shellcheck passes with no errors
3. ‚úÖ --risk flag is opt-in (doesn't affect default behavior)
4. ‚úÖ Config error disables risk scoring gracefully (no crash)
5. ‚úÖ Console output is clean and readable
6. ‚úÖ JSON schema includes risk_* fields when --risk enabled
7. ‚úÖ No JSON parsing with grep (uses associative arrays)
8. ‚úÖ Per-target arrays initialized correctly
9. ‚úÖ ENABLE_RISK=false respected throughout

## Notes for Implementation

- The full calculate_risk_score() function is ~150 lines - reference the session design doc
- The print_risk_summary() function is ~100 lines - reference the session design doc
- The print_risk_detail() function is ~80 lines - reference the session design doc
- All three functions are fully spec'd in the v1.5.0 design from this session
- Use awk for JSON parsing, never grep on JSON strings
- Test with multiple users to ensure associative arrays work correctly
- Verify memory usage is reasonable (pure bash should be efficient)

## After v1.5.0 Ships

Next release (v1.6.0) will add drift tracking:
- Snapshot storage in `logs/ssh-key-audit/snapshots/`
- `--delta` mode for comparison
- Track: additions, removals, degradations, improvements
- Pair with risk scores: "Risk jumped from MEDIUM to CRITICAL"
